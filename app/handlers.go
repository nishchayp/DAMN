package app

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"github.com/julienschmidt/httprouter"
	"golang.org/x/oauth2"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
)

/*
** contains handler fuctions which do not require admin account
** contains fuctions to interact with OAuth2
 */

var state string

func randState() string {

	// generates random string

	b := make([]byte, 32)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {

	var indexTemplate *template.Template
	indexTemplate = template.Must(template.ParseGlob("templates/index.html"))
	indexTemplate.Execute(w, nil)

}

func LoginHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {

	// calls Google OAuth2 api endpoint on the provided configuration

	http.Redirect(w, r, confOAuth2.AuthCodeURL(state), 302)
}

func Options(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {

	// callback after user is authenticated via OAuth2

	// checks if the state appended to callback url is same as generated by app
	// thus ensures the callback is not from a man in the middle
	if r.FormValue("state") != state {
		http.Error(w, "Possibly malacious/fake callback redirect", http.StatusBadRequest)
		log.Printf("Possibly malacious/fake callback redirect. Random state does not match\nError: %v\n", http.StatusBadRequest)
		return
	}

	// call Exchange on conf to get token from Google OAuth2 api
	// pass code recieved as callback url parameter
	tok, err := confOAuth2.Exchange(oauth2.NoContext, r.FormValue("code"))
	if err != nil {
		http.Error(w, "Could not exchange code for google token", http.StatusBadRequest)
		log.Printf("Could not exchange code for google token.\nError: %v\n", err.Error())
		return
	}

	// authenticate the google token obtained by calling endpoint
	// provided by google for token authentication
	check, err := http.Get("https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=" + tok.AccessToken)
	if err != nil {
		http.Error(w, "Google token not authentic", http.StatusBadRequest)
		log.Printf("Google token not authentic.\nError: %v\n", err.Error())
		return
	}
	defer check.Body.Close()

	// use token to get user info
	client := confOAuth2.Client(oauth2.NoContext, tok)
	info, err := client.Get("https://www.googleapis.com/oauth2/v3/userinfo")
	if err != nil {
		http.Error(w, "User info could not be obtained", http.StatusBadRequest)
		log.Printf("User info could not be obtained.\nError: %v\n", err.Error())
		return
	}
	defer info.Body.Close()
	data, _ := ioutil.ReadAll(info.Body)

	var googTok GoogleToken

	json.Unmarshal(data, &googTok)

	// check if user has a verified gmail account
	if googTok.EmailVerified == false {
		http.Redirect(w, r, "https://myaccount.google.com/", 302)
		return
	}

	// set google token as cookie
	SetCookieHandler(&googTok, w)

	log.Printf("%v logged in using account %v", googTok.Name, googTok.Email)

	var admin Admin

	if DB.db.Where("email = ?", googTok.Email).First(&admin).RecordNotFound() {
		http.Redirect(w, r, "/", 302)
	} else {
		var adminTemplate *template.Template
		adminTemplate = template.Must(template.ParseGlob("templates/admin.html"))
		adminTemplate.Execute(w, nil)
	}

}

func LogoutHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {

	// clears cookie logs out user

	ClearCookieHandler(w)
	http.Redirect(w, r, "/", 302)

}

func MakeAccessRequest(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {

	// make request to get access to server user wants to work on

	// request contains user's ssh key and message describing the project
	// they are working on
	type Receive struct {
		SshKey  string `json:"ssh_key"`
		Message string `json:"message"`
	}

	var response Response

	decoder := json.NewDecoder(r.Body)
	var receive Receive
	err := decoder.Decode(&receive)
	if err != nil {
		http.Error(w, "Error reading the received request", http.StatusBadRequest)
		log.Printf("Error reading the received request.\nError: %v\n", err.Error())
		return
	}

	googTok := ReadCookieHandler(w, r)

	if googTok.Email == "" {
		response = Response{
			false,
			"User not authenticated",
		}
	} else {

		var accessRequest AccessRequest

		// register new request if it does not already exists
		if DB.db.Where("email = ?", googTok.Email).First(&accessRequest).RecordNotFound() == true {
			accessRequest = AccessRequest{
				Name:    googTok.Name,
				Email:   googTok.Email,
				Message: receive.Message,
				SshKey:  receive.SshKey,
			}

			DB.db.Create(&accessRequest)

			response = Response{
				true,
				"New request sent",
			}
		} else {
			response = Response{
				false,
				"Request already exists",
			}
		}

	}

	json, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(json)

}

func MakeAdminRequest(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {

	// make request to get admin privileges for DAMN portal

	var response Response

	googTok := ReadCookieHandler(w, r)

	if googTok.Email == "" {
		response = Response{
			false,
			"User not authenticated",
		}
	} else {

		var adminRequest AdminRequest
		var admin Admin

		// register new request if it does not already exists
		if DB.db.Where("email = ?", googTok.Email).First(&adminRequest).RecordNotFound() == false {
			response = Response{
				false,
				"Request already exists",
			}
		} else if DB.db.Where("email = ?", googTok.Email).First(&admin).RecordNotFound() == false {
			response = Response{
				false,
				"User is already an admin",
			}
		} else {
			adminRequest = AdminRequest{
				Name:  googTok.Name,
				Email: googTok.Email,
			}

			DB.db.Create(&adminRequest)

			response = Response{
				true,
				"New request sent",
			}
		}

	}

	json, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(json)

}
